#include "ERNeuRadSetup.h"

#include "TError.h"
#include "TMath.h"

#include "FairRootManager.h"
#include "FairRunAna.h"
#include "FairRuntimeDb.h"
#include "FairLogger.h"

ERNeuRadSetup* ERNeuRadSetup::fInstance = NULL;
ERNeuRadDigiPar* ERNeuRadSetup::fDigiPar;
std::vector<ERNeuRadBundle*> ERNeuRadSetup::fBundles;
std::vector<std::vector<ERNeuRadFiber*> > ERNeuRadSetup::fFibers;
Int_t ERNeuRadSetup::fNofFiberInRow;
Int_t ERNeuRadSetup::fNofBundlesInRow;
Float_t ERNeuRadSetup::fFiberWidth;
Float_t ERNeuRadSetup::fBundleWidth;
Float_t ERNeuRadSetup::fNeuradWidth;

ERNeuRadSetup::ERNeuRadSetup(){
	// Get run and runtime database
	FairRunAna* run = FairRunAna::Instance();
	if ( ! run ) Fatal("ERNeuRadSetup", "No analysis run");

	FairRuntimeDb* rtdb = run->GetRuntimeDb();
	if ( ! rtdb ) Fatal("ERNeuRadSetup", "No runtime database");

	fDigiPar = (ERNeuRadDigiPar*)
             (rtdb->getContainer("ERNeuRadDigiPar"));
	if ( ! fDigiPar ) Fatal("ERNeuRadSetup", "No ERNeuRadDigiPar in runtime");

	fNofFiberInRow = Int_t(TMath::Sqrt(fDigiPar->NofFibers()));
	fNofBundlesInRow = Int_t(TMath::Sqrt(fDigiPar->NofBundles()));
	fFiberWidth = fDigiPar->FiberWidth();
	fBundleWidth = fNofFiberInRow*fFiberWidth;
	fNeuradWidth = fBundleWidth*fNofBundlesInRow;
	//Инициализируем бандлы
	for(Int_t iBundle = 0; iBundle < fNofBundlesInRow; iBundle++ ){
		for(Int_t jBundle = 0; jBundle < fNofBundlesInRow; jBundle++ ){
			Float_t bundleX = fNeuradWidth/2. - iBundle*fBundleWidth - fBundleWidth/2.;
			Float_t bundleY = fNeuradWidth/2. - jBundle*fBundleWidth - fBundleWidth/2.;
			fBundles.push_back(new ERNeuRadBundle(bundleX,bundleY));
			std::vector<ERNeuRadFiber*> fibersInBundle;
			//Инициализируем файберы в бандле
			for (Int_t iFiber = 0; iFiber < fNofFiberInRow; iFiber++){
				for (Int_t jFiber = 0; jFiber < fNofFiberInRow; jFiber++){
					Float_t fiberX = bundleX + fBundleWidth/2. - iFiber*fFiberWidth - fFiberWidth/2.;
					Float_t fiberY = bundleY + fBundleWidth/2. - jFiber*fFiberWidth - fFiberWidth/2.;
					fibersInBundle.push_back(new ERNeuRadFiber(fiberX,fiberY));
				}
			}
			fFibers.push_back(fibersInBundle);
		}
	}
	LOG(INFO) << "ERNeuRadSetup::ERNeuRadSetup() "<< FairLogger::endl;
    LOG(INFO) << "ERNeuRadSetup initialized! "<< FairLogger::endl;
}

ERNeuRadSetup* ERNeuRadSetup::Instance(){
	if (fInstance == NULL)
		return new ERNeuRadSetup();
	else
		return fInstance;
}

Int_t  ERNeuRadSetup::NofFibers() {
	return fDigiPar->NofFibers();
}

Int_t   ERNeuRadSetup::NofBundles() {
	return fDigiPar->NofBundles();
}

Float_t ERNeuRadSetup::FiberLength() {
	return fDigiPar->FiberLength();
}

Float_t ERNeuRadSetup::FiberWidth() {
	return fDigiPar->FiberWidth();
}

Float_t ERNeuRadSetup::BundleX(Int_t iBundle){
	return fBundles[iBundle]->fX;
}

Float_t ERNeuRadSetup::BundleY(Int_t iBundle){
	return fBundles[iBundle]->fY;
}

Float_t ERNeuRadSetup::FiberX(Int_t iBundle, Int_t iFiber){
	return fFibers[iBundle][iFiber]->fX;
}

Float_t ERNeuRadSetup::FiberY(Int_t iBundle, Int_t iFiber){
	return fFibers[iBundle][iFiber]->fY;
}

Float_t ERNeuRadSetup::PMTQuantumEfficiency(Int_t iBundle, Int_t iFiber){
	return fDigiPar->PMTQuantumEfficiency(iFiber);
}

Float_t ERNeuRadSetup::PMTGain(Int_t iBundle, Int_t iFiber){
	return fDigiPar->PMTGain(iFiber);
}

void ERNeuRadSetup::Print(){
	fDigiPar->print();
}

Int_t ERNeuRadSetup::GetNeighborFiber(const Int_t point_bundle,const Int_t point_fiber_nb, Int_t& neighborBundle, Int_t& neighborFiber){
	//соседи считаются по часовой стрелке. начало - левый верхний
	neighborFiber  = -1;
	neighborBundle = -1;
	/*switch (neighbor){
		case 0:
			neighborFiber = point_fiber_nb - fNofFiberInRow -1;
			if (neighborFiber < 0){
				neighborBundle = TopBundleNeighbor(point_bundle); //возможно ли?
				if (neighborBundle == -1){
					neighborFiber = -1;
				}
				else{
					neighborFiber = NofFibers() - neighborFiber;
					if ((neighborFiber+1)%fNofFiberInRow == 0) )
						neighborFiber = -1;
				}
			} 
			break;
		case 1:
			neighborFiber = point_fiber_nb - fNofFiberInRow;
			if (neighborFiber < 0){
				neighborBundle = TopBundleNeighbor(point_bundle);
				if (neighborBundle == -1)
					neighborFiber = -1;
				else
					neighborFiber = NofFibers() - neighborFiber;
			} 
			break;
		case 2:
			neighborFiber = point_fiber_nb - fNofFiberInRow + 1;
			if (neighborFiber < 0) neighborFiber = -1;
			break;
		case 3:
			neighborFiber = point_fiber_nb - 1;
			if ( (neighborFiber+1)%8 == 0) neighborFiber = -1;

	}
	*/
	return neighborFiber; //-1 вышли за детектор
}

Int_t ERNeuRadSetup::TopBundleNeighbor(Int_t bundle){
	Int_t neighborBundle = bundle - fNofBundlesInRow;
	if (neighborBundle < 0)
		return -1;
} 

ClassImp(ERNeuRadSetup)
