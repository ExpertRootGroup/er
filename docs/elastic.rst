.. Автозамены
.. |empty| unicode:: U+2063

Постановка задачи упругого рассеяния
------------------------------------

Ион **А** с энергией \ :sup:`A`\ **E**\ :sub:`0`, импульсом \ :sup:`A`\ **P**\ :sub:`0`\(**P**\ :sub:`x`, **P**\ :sub:`y`, **P**\ :sub:`z`),
начальными пространственными координатами \ :sup:`A`\ **r**\ :sub:`0`\(**x**\ :sub:`0`, **y**\ :sub:`0`, **z**\ :sub:`0`) налетает на покоящуюся мишень
состоящую из атомов **B**.
Ион **A** многократно рассеивается внутри обьема мишени, на некотором шаге выбивает ион **B**, и далее уже оба иона многократно рассеиваютя пока не покинут обьем мишени. 
В результате - новые характеристики \ :sup:`A`\ **E**\, \ :sup:`A`\ **P(P**\ :sub:`x`, **P**\ :sub:`y`, **P**\ :sub:`z`), \ :sup:`A`\ **r(x**, **y**, **z**)- для иона **А**,
и следующие для иона **B**: \ :sup:`B`\ **E**\, \ :sup:`B`\ **P(P**\ :sub:`x`, **P**\ :sub:`y`, **P**\ :sub:`z`), \ :sup:`B`\ **r(x**, **y**, **z**).

.. figure:: _static/fig1.png
   :height: 50px
   :width: 100 px
   :align: center

Рассмотрим добавления упругого рассеяния в сессию симуляции на примере рассейния иона 15N на мишени 11B. Создаем класс коллекции взаимодействий и класс взаимодействия::

    ERDecayer* decayer = new ERDecayer();
    ERElasticScattering* scattering = new ERElasticScattering("15Nto15N11B");
    
15Nto15N11B - Имя взаимодействия. 

Входные данные
--------------

Пользователь должен знать:

#. Следующие характеристики ионов:
    * A - атомная масса
    * Z - число протонов
    * Q - заряд

    Для налетающего иона, например для \ :sup:`15`\N, данные характеристике задаются так::

        scattering->SetInputIon(7,15,3); // Z = 7, A = 15, Q = 3

    А для иона мишени, например \ :sup:`11`\B так::

        scattering->SetTargetIon(5,11,5); // Z = 5, A = 11, Q = 5
    
#. Кумулятивную функцию угла рассеяния theta (в случае не изотропного распределения theta). 

    Задаём имя текстового файла с данными о кумулятивной функции::

        scattering->SetThetaCDF("cos_tetta_cross.txt");

    Структура текстового файла должна быть следующая::

        4.5 0.0448573496944
        4.6 0.087071447189
        4.7 0.126858356665
        4.8 0.164410246312
        4.9 0.199891413123
        5.0 0.233459173925
        5.1 0.26523651571
        5.2 0.295359837723

        ... ... 

        179.3 0.99999999789
        179.4 0.999999998493
        179.5 0.999999998995
        179.6 0.999999999397
        179.7 0.999999999698
        179.8 0.999999999899
        179.9 1.
        180.0 1.

    Где первый столбец соответствует углам \theta в системе центра масс, а второй — значениям кумулятивной функции для данных значений углов \theta.
    Текстовый файл с данными о кумулятивной функции должен лежать в директории **er/input** .

#. Толщину мишени.
    Это можно задать двумя способами:    if (!ERDecay::Init())
    {
        return kFALSE;
    }

    fTargetIonPDG = TDatabasePDG::Instance()->GetParticle(fTargetIonName);
    if ( ! fTargetIonPDG )
    {
        LOG(FATAL) << "Target ion not found in pdg database!" << FairLogger::endl;
        return kFALSE;
    }
    
    * Для изотропного розыгрыша координаты взаимодействия внутри объёма мишени. Задать переднюю координату мишени и заднюю относительно глобальной оси **z**: ::

        scattering->SetUniformPos(-0.00035,0.00035); // target width 7 micron
        
      .. tip:: Использовать в случае **тонкой** мишени.
      
    .. figure:: _static/fig2.png
        :height: 50px
        :width: 100 px
        :align: center

        Обычно мишень располагается в начале глобальной системы координат, данный рисунок иллюстрирует этот случай. 
         
    * Для экспоненциального розыгрыша координаты взаимодействия, используйте метод::

        SetExponentialPos(Double_t start, Double_t tau);
       
      .. tip:: Использовать в случае **толстой** мишени.
   
#. Желательный шаг транспорта первичного иона внутри объёма мишени.
   Здать его нужно следующим образом::
   
    scattering->SetStep(0.00001); //0.1 micron

#. Пользователь может выбрать необходимый диапозон розыгрыша углов theta *CM* двумя способами:   
    #. Диапозон розыгрыша расчитывается на основании следующих величин: 
        * **Полуширина** щели детектора dtheta по \theta в лабороторной системе координат, которую нужно задать::
    
                scattering->SetDetThetaWidth(0.262822833); // Detectors theta width
   
          .. attention:: Важно выбирать данную велечину с запасом!

          .. figure:: _static/fig3.png
              :height: 50px
              :width: 100 px
              :align: left  
  
        * Координата theta *Lab* центра щели детектора::

            scattering->SetDetTheta(theta); 

            Дипозон розыгрыша theta *CM* (fTheta1 - певая координата по theta, fTheta2 - вторая) углов по кумулятивной функции, вычисляется по следующим формулам:

          .. figure:: _static/formulas.png
              :height: 50px
              :width: 100 px
              :align: left
      
    #. Пользователь может выбрать диапозон розыгрыша углов theta *CM* явным образом::
    
            scattering->SetThetaRange(18.4, 19.4);
                 
  .. tip::
       Предпочтительнее использовать первый способ! 
              
Механизм работы класса
----------------------

Добавляем упругое рассеяние в коллекцию распадов::

  decayer->AddDecay(scattering);  

Ниже опишем что будет происходить поле этого.

Класс ElasticScattering содержит два основных метода: Intit(), Stepping().

Bool_t ElasticScattering::Init()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Данный метод вызывается в самом начале симуляции, на этапе инициализации. 
Здесь проверяется ::

    if (!ERDecay::Init())
    {
        return kFALSE;
    }

    fTargetIonPDG = TDatabasePDG::Instance()->GetParticle(fTargetIonName);
    if ( ! fTargetIonPDG )
    {
        LOG(FATAL) << "Target ion not found in pdg database!" << FairLogger::endl;
        return kFALSE;
    }
    
Расчитывается диапозон розыгрыша углов theta *CM* - вызовом метода::
    
    ERElasticScattering::RangesCalculate(Double_t iM, Double_t tM)
    
где iM - масса налетающего иона, а tM - иона мишени.

.. note:: В случае явного определения диапозона розыгрыша theta *CM*, метод описанный выше не вызывается! 

Так же здесь формируется кумулятивная функция. Из диапозона theta *CM* вычисляется соотвесвующий диапозон внутри кумулятивной функции. 

Bool_t ElasticScattering::Steping()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Вызывается на каждом шаге траспорта налетающего иона внутри обьема мишени.

Здесь разыгрываются углы вылета для ионов - налетающего и мишени, следующим образом::
    
    // Generate random angles theta and phi
    Double_t theta = ThetaGen();
    Double_t phi = fRnd->Uniform(fPhi1*DegToRad(), fPhi2*DegToRad());
    
Связь лабороторной и цетра масс систем
--------------------------------------

